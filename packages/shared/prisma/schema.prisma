generator client {
  provider = "prisma-client-js"
  output   = "../../../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String   @id @default(uuid())
  lineId_hash    String?  @unique
  lineId_enc     String?

  lineKeyVersion_hash String  @default("K1")
  lineKeyVersion_enc String  @default("K1")
  consentAt      DateTime? @default(now())

  name           String
  pictureUrl     String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime?         @updatedAt

  userStores     UserStore[]
  submittedShifts SubmittedShift[]
  jobRoles      UserJobRole[]
}

enum UserRole {
  OWNER
  MANAGER
  STAFF
}

model Store {
  id               String   @id @default(uuid())
  groupId_hash     String?  @unique
  groupId_enc      String?
  groupKeyVersion_hash  String  @default("K1")
  groupKeyVersion_enc  String  @default("K1")
  consentAt        DateTime? @default(now())
  isActive         Boolean  @default(true)

  name             String           @unique
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  userStores       UserStore[]      
  shiftRequests    ShiftRequest[]   
  assignShifts     AssignShift[]   
  submittedShifts  SubmittedShift[] 
  payment          Payment?
  ShiftPosition    ShiftPosition[]
  jobRoles         JobRole[]
  storeCode        StoreCode?
}

// 中間テーブル（ユーザーと店舗の M:N 関係）
model UserStore {
  userId   String
  storeId  String
  role     UserRole

  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  store    Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  createdAt        DateTime         @default(now())
  updatedAt        DateTime?        @updatedAt

  @@id([userId, storeId])
}

model StoreCode {
  id         String   @id @default(uuid())
  storeId    String   @unique
  code_hash  String   @unique 
  code_enc   String
  codeKeyVersion_hash String   @default("K1")
  codeKeyVersion_enc  String   @default("K1")

  rotatedAt  DateTime?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  store      Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
}

// シフト募集データ
model ShiftRequest {
  id              String          @id @default(uuid())
  storeId         String
  weekStart       DateTime
  weekEnd         DateTime
  requests        Json
  type            ShiftType       @default(WEEKLY)
  status          RequestStatus   @default(HOLD)
  deadline        DateTime?

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  store           Store           @relation(fields: [storeId], references: [id], onDelete: Cascade)

  assignShift     AssignShift?    
  submittedShifts SubmittedShift[]

  @@unique([storeId, weekStart])
}

enum ShiftType {
  MONTHLY
  WEEKLY
}

enum RequestStatus {
  HOLD
  REQUEST
  ADJUSTMENT
  CONFIRMED
}

// 確定シフトデータ（店舗用）
model AssignShift {
  id              String        @id @default(uuid())
  storeId         String
  shiftRequestId  String        @unique 
  shifts          Json
  status          ShiftStatus   @default(ADJUSTMENT)

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  store           Store         @relation(fields: [storeId], references: [id], onDelete: Cascade)
  shiftRequest    ShiftRequest  @relation(fields: [shiftRequestId], references: [id], onDelete: Cascade)
}


enum ShiftStatus {
  ADJUSTMENT
  CONFIRMED
}

// ユーザーの提出シフト
model SubmittedShift {
  id              String         @id @default(uuid())
  userId          String
  storeId         String
  shiftRequestId  String
  shifts          Json
  memo            String?
  status          ShiftStatus

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  store           Store          @relation(fields: [storeId], references: [id], onDelete: Cascade)
  shiftRequest    ShiftRequest   @relation(fields: [shiftRequestId], references: [id], onDelete: Cascade)

  @@unique([userId, shiftRequestId])
}




model JobRole {
  id        String        @id @default(cuid())
  name      String
  storeId   String
  users     UserJobRole[]


  store      Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  @@unique([storeId, name])
}

model UserJobRole {
  id        String     @id @default(cuid())
  userId    String
  roleId    String
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      JobRole    @relation(fields: [roleId], references: [id],  onDelete: Cascade)
  @@unique([userId, roleId])
}


model ShiftPosition {
  id         String   @id @default(cuid())
  storeId    String
  name       String
  startTime  DateTime
  endTime    DateTime
  jobRoles   String[]
  count      Int?
  absolute   Json?
  priority   Json?
  weeks      String[]


  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  
  store      Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  @@unique([storeId, name])
}



// Stripe連携などの支払い情報
model Payment {
  id                          String   @id @default(uuid())
  storeId                     String   @unique
  userId                      String
  customerId                  String
  subscriptionId              String
  productId                   String?   // Stript 商品ID
  priceId                     String   // Stripe Price ID
  price_amount                Int?      // 単位: 円
  price_interval              String?   // "month" | "year"
  subscription_status         String   // active, trialing, canceled, etc.

  isTrial                     Boolean  @default(false) // 無料トライアル中かどうか
  trial_end_date              DateTime?                // トライアル終了日
  trial_end_notification_sent Boolean  @default(false) // トライアル終了通知済か

  cancel_requested_at         DateTime?                // 解約予約日
  cancel_at_period_end        Boolean  @default(false) // 次回請求で自動キャンセルか
  delete_scheduled_at         DateTime?                // データ削除予定日時
  deleted_at                  DateTime?                // 実際の削除日（or 論理削除用）

  current_plan                String   // 例: "basic", "pro", etc
  next_billing_date           DateTime?

  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt

  store                       Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
}

